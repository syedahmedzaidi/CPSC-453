CPSC453 - Assignment 1

NAME: Syed Ahmed Hassan Zaidi
UCID Number: 10150285
Tutorial Section: Tutorial 04

=== 1. EXECUTION: ===

To compile the program, on the terminal enter the following commands:

	qmake -project QT+=widgets
	qmake
	make

To run the program, on the terminal enter the following command:

	./a1

=== 2. PROGRAM USE: ===


To play the game run the program through the terminal. The game will automatically start.
Fill in the rows to keep playing. If the pieces all collect to the top of the well, you lose.
To play again, press N. To pause the game, press P. To quit anytime in between the game, press Q.

During the play you can rotate the view of the game. To rotate about the Y axis, keep pressing the
middle button and drag your mouse cursor. To rotate about the X axis, keep pressing the left button
and drag your mouse cursor. To rotate about the Z axis, keep pressing the right button and drag your
mouse cursor. If at any time you let go of the mouse button you are pressing, the view of the game
will keep rotating about the axis according to the mouse button you had pressed.

You can scale the view of the game by pressing the SHIFT button on keyboard and dragging your mouse.
If you move your cursor towards the left of the screen, the screen will zoom out. If you move the
cursor towards the right, it will zoom in.

If at any time, you wish to go to default view of the game, press R.

You can switch the modes of the game by pressing W,F,M. If you press W, the game will be drawn in wire
frame mode. If you press F, each cube will have different color. If you press M, multi colored mode will
be activated.

To increase the speed of the game, press PGUP button on keyboard. To decrease the speed of the game,
press PGDN button on the keyboard. You can also gradually increase the speed of the game by pressing
the A button.

== 3. ALGORITHMS and DESIGN DECISIONS: ===

Creating a Cube, the well, Gameplay:

- The cube has been generated by loading the cube vertices and normals and defining an array of generic
  vertex attribute data.
- The vertices and the normal were provided by our TA - Amirhessam Moltaji. They are available on his course
  website (http://moltaji.cpsc.ucalgary.ca/Courses/) under CPSC453 F15.
- After loading the vertices and normals in a vector, I proceeded to draw the cube in paintGL() using a for loop.
- Using 3 for loops, i created a well. Two for loops have the condition from i = 0 to i < 24. These two for loops
  create the vertical standing wall of the well. One for loop has the condition from i =0 to i<10, which creates the
  horizontal, bottom wall of the well.
- The main game loop is a nested for loop of stage 2, where the condiition sare that each row and color (c ,r) are less than 24 and 10 respectivley.
  In the nested for loop an INT variable block is declared and initialized with the value which we get by calling get(column, row) method which resides
  in game call through our pointer to that class (m_pGame). It is later described below how each piece is generated.

WireFrame, Face, Multicolored Mode:

- To render the game in wire frame mode, I first created an enum structure DrawMode, this serves as
  variables of either WIRE, FACE, MULTI.
- I also have a variable m_mode of type DrawMode. In my paintGL() function, i have an if condition that states; if
  m_mode is equal to WIRE, then i call glPolygonMode( GL_FRONT_AND_BACK, GL_LINE) followed by an update, which renders
  the screen in Lines(wire frame). Else m_mode is equal to FACE, and for that glPolygonMode( GL_FRONT_AND_BACK, GL_FILL ) is called
  which renders the screen with each triangle filled front and back.
- A private function setMode is also implemented which takes in 1 argument of type DrawMode. What ever valid DrawMode type is given to
  the function, m_mode is set to that.
- 3 public slots (setWireMode, setFaceMode, setMultiMode) are also implemented. As the name suggest each one of them sets m_mode accordingly
  by calling the private function setMode with arguments according to what their name suggest. They are public slots because they are called
  and used by connect function in window.cpp which hooks these functions to the keys W,F,M according to which mode needs to be set.
- For face mode, with in main game loop: it checks which mode is set. If m_mode is set to FACE it goes into that loop, where there are several
  switch cases. Each switch case is dependant on the value of block variable. If that block variable is any of the following numbers: 0,1,2,3,4,5,6
  It calls setNewColor method. This method takes in one argument of type QColor. setNewColor sets that color into the boxColor vector and when it goes back
  to paintGL(), each block is drawn to the color appropriate to it. The next piece comes in thanks to our method timer_tick() which calls the tick() method from
  our game class through the pointer we declared (m_pGame).

Rotation & Scaling:

- Rotation is implemented in 3 functions (mousePressEvent, mouseMoveEvent, mouseReleaseEvent). In mousePressEvent, it is determined which
  button is pressed, and which ever button is pressed, float variables (rotX, rotY, rotZ) are initialized to the x corrdinate of the point
  the user clicked on the screen. Along with each variable being initialized, a boolean type variables (rotate_horizontal, rotate_vertical, rotate_3d)
  are also set to true. The purpose of these boolean variables are more effective in mouseMoveEvent but for now it serves the purpose that which axis you
  are about to rotate in.
- In mouseMoveEvent, and If condition for Scaling comes first. A boolean variable toScale is set true if the button SHIFT is pressed. The original start point x is then subtracted
  from the point your cursor is currently at after movement. It then scales it using math formulas to keep scaling of view_matrix controlable. The boundarys of scaling are set
  and after that scale method is called on the view_matrix.
- Other if conditions are then checked if shift key hasnt been pressed. This is where the boolean variables (rotate_horizontal, rotate_vertical, rotate_3d) are effective.
  Which ever bool variable is true and toScale is not true, it goes into that condition and subtracts the according variable (rotX, rotY, rotZ) from the point you cursor is currently
  on, and stores it into another float variable (theta, alpha, beta). It then calls the rotate method on the view_matrix right away so that during the game play, the rotation is applied to
  the view right when you move your mouse. This is temporary rotation.
- In mouseReleaseEvent is where the persistance is done and the rotation is set permenantly. It checks which button has been released. Which ever button is released it sets a boolean variable
  called keepRotate to true and calls update(). This updates the screen and goes into paintGL(). This is where persistance is done. With in paintGL(), there is an If condition that checks if
  keepRotate is true. If it is true, it proceeds to check which axis of rotation is true, for that axis rotation it called rotate function of view_matrix with last saved float rotation values
  (theta, alpha, beta).

Reset view, New Game, Pause game:

- To reset view of the game, all the variable that are used in rotation scaling are first set to their default values. Then the view_matrix is set to identity matrix, and then translated back to
  the default coodinated(0.0f, 0.0f, -40.0f). This is done with in a method called resetView() which is declared as a public slot in renderer.h. This is done because resetView() has to be hooked to
  the button R, thus for that reason it is declared as a public slot.
- To start a new Game, a method called newGame() is declared as a public slot. It is declared as a public slot because it is to be hooked with the button N in our widget UI. The method calls our game class method reset()
  through our pointer to that class (m_pGame). It then sets the speed interval to original value through a privated method in renderer class called setSpeedInterval(int). setSpeedInterval(int) takes the INT value and sets
  it as our speed in miliseconds using the slot start() which resides in QTimer class through our pointer to that class (gTimer).

- To pause the game, the method pauseGame() is declared as a public slot and hooked to the button P in our widget. pauseGame() method calls the slot stop() which resides in QTimer class through our pointer to that class (gTimer).
  It stops the timer.

Key buttons for gameplay:

-With in the window.cpp keyPressEvent method is declared. It takes in one argument, a pointer to QKeyEvent. The method has switch case that detects a ket event, and check if that key event is either one of the following:
 1. Up key
 2. Down key
 3. Left key
 4. Right key
 5. Space key

- If Up key is detected, it calls rotateCCW method from poiner renderer which poins to renderer class. rotateCCW is actually a method that exist in game class but is also initialized in renderer class.
- If Down key is detected, it calls rotateCW method from poiner renderer which poins to renderer class. rotateCW is actually a method that exist in game class but is also initialized in renderer class.
- If Left key is detected, it calls moveLeft method from poiner renderer which poins to renderer class. moveLeft is actually a method that exist in game class but is also initialized in renderer class.
- If Right key is detected, it calls moveRight method from poiner renderer which poins to renderer class. moveRight is actually a method that exist in game class but is also initialized in renderer class.
- If Space key is detected, it calls drop method from the poiner renderer which poins to renderer class. drop is actually a method that exist in game class but is also initialized in renderer class.



=== 4. FILES SUBMITTED: ===

A zip file has been submitted which contains the following:

-game.cpp
-game.hpp
-main.cpp
-renderer.cpp
-renderer.hpp
-window.cpp
-window.hpp
-per-fragment-phong.fs.glsl
-per-fragment-phong.vs.glsl
-README


=== 5. PROGRAM ASSUMPTIONS: ===

The following assumptions are made:

- If the board is filled to the very top of the well, The user has lost and will restart the
  game by pressing N.

=== 6. DECLARATION AND IMAGE PERMISSION: ===


_X_ I have read the regulations regarding plagarism. I affirm with my initials
that I have worked on my own solution to this assignment, and the code I am
submitting is my own.

<Mark with an X if desired. No marks will be deducted either way>

_X_ I grant the instructor and/or TAs permission to use images submitted and/or
   assignment screenshots for future CPSC453 courses.

_X_ If permission has been granted above, I would prefer the images to remain
   annonymous. <Otherwise credit will be given, as is due>

_X_
